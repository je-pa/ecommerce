# 🛒ECOMMERCE

> ### Project
> 🔗 [프로젝트 관리](https://github.com/users/je-pa/projects/2)
> ### Monolithic Architecture
> 🔗 [MONOLITHIC ECOMMERCE](https://github.com/je-pa/ecommerce)
> 
> ### MicroService Architecture
>  
> 🔗 [USER SERVICE](https://github.com/je-pa/ecommerce-user)
> 🔗 [PRODUCT SERVICE](https://github.com/je-pa/ecommerce-product)
> 🔗 [ORDER SERVICE](https://github.com/je-pa/ecommerce-order)
>
> 🔗 [GATEWAY](https://github.com/je-pa/scg-ecommerce)
> 🔗 [EUREKA SERVER](https://github.com/je-pa/eureka-server-ecommerce)
> 
> 🔗 [CONFIG SERVER(PRIVATE)](https://github.com/je-pa/config-server-ecommerce)
> 🔗 [CONFIG REPOSITORY(PRIVATE)](https://github.com/je-pa/config-ecommerce)
>
> ![image](https://github.com/user-attachments/assets/e3360ae2-44a7-405c-81b1-75efe2baea3a)

## ⭐ 기술 스택

<table>
  <tr>
    <th style="font-weight: bold;">분류</th>
    <th style="font-weight: bold;">기술</th>
    <th style="font-weight: bold;">비고</th>
  </tr>
  <tr>
    <td rowspan="1">프로그래밍 언어</td>
    <td><img src="https://img.shields.io/badge/java 21-007396?style=flat&logo=Java&logoColor=white" alt="Java" /></td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="1">빌드 도구</td>
    <td><img src="https://img.shields.io/badge/Gradle-02303A?style=flat&logo=Gradle&logoColor=white" alt="Gradle" /></td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="2">프레임워크</td>
    <td><img src="https://img.shields.io/badge/Spring_Boot 3.3.x-6DB33F?style=flat&logo=SpringBoot&logoColor=white" alt="Spring Boot" /></td>
    <td></td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Spring_Security-6DB33F?style=flat&logo=SpringSecurity&logoColor=white" alt="Spring Security" /></td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="1">ORM</td>
    <td><img src="https://img.shields.io/badge/JPA(Hibernate)-59666C?style=flat&logo=hibernate&logoColor=white" alt="JPA(Hibernate)" /></td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="3">데이터베이스</td>
    <td><img src="https://img.shields.io/badge/MySQL-4479A1?style=flat&logo=mysql&logoColor=white" alt="MySQL" /></td>
    <td></td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/H2-59666C?style=flat&logoColor=white" alt="H2" /></td>
    <td>테스트 DB</td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Redis-DC382D?style=flat&logo=redis&logoColor=white" alt="Redis" /></td>
    <td>캐시</td>
  </tr>
  <tr>
    <td rowspan="3">테스트 도구</td>
    <td><img src="https://img.shields.io/badge/JUnit5-25A162?style=flat&logo=junit5&logoColor=white" alt="JUnit5" /></td>
    <td>통합 테스트</td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Mockito-3FCF8E?style=flat&logoColor=white" alt="Mockito" /></td>
    <td>단위 테스트</td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/JaCoCo-B90000?style=flat&logo=java&logoColor=white" alt="JaCoCo" /></td>
    <td>테스트 커버리지 리포트</td>
  </tr>
  <tr>
    <td rowspan="1">정적 분석 도구</td>
    <td><img src="https://img.shields.io/badge/SonarQube-4E9BCD?style=flat&logo=sonarqube&logoColor=white" alt="SonarQube" /></td>
    <td>코드 품질 분석</td>
  </tr>
  <tr>
    <td rowspan="1">쿼리 빌더</td>
    <td><img src="https://img.shields.io/badge/QueryDSL-00599C?style=flat&logo=java&logoColor=white" alt="QueryDSL" /></td>
    <td></td>
  </tr>
  <tr>
   <td rowspan="2">인증/인가</td>
    <td><img src="https://img.shields.io/badge/JWT-000000?style=flat&logo=JSON%20Web%20Tokens&logoColor=white" alt="JWT" /></td>
    <td></td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Google%20SMTP-4285F4?style=flat&logo=gmail&logoColor=white" alt="Google SMTP" /></td>
    <td>mail 인증</td>
  </tr>
  <tr>
    <td rowspan="1">컨테이너화 도구</td>
    <td><img src="https://img.shields.io/badge/Docker-2496ED?style=flat&logo=docker&logoColor=white" alt="Docker" /></td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="3">클라우드</td>
    <td><img src="https://img.shields.io/badge/Spring_Cloud 2023.0.3-6DB33F?style=flat&logo=Spring&logoColor=white" alt="Spring Cloud" /></td>
    <td></td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Spring_Cloud_Config-6DB33F?style=flat&logo=Spring&logoColor=white" alt="Spring Cloud Config" /></td>
    <td></td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Spring_Cloud_Gateway-6DB33F?style=flat&logo=Spring&logoColor=white" alt="Spring Cloud Gateway" /></td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="2">서비스 디스커버리</td>
    <td><img src="https://img.shields.io/badge/Eureka-4285F4?style=flat&logoColor=white" alt="Eureka" /></td>
    <td></td>
  </tr>
  <tr>
    <td><img src="https://img.shields.io/badge/Eureka_Client-4285F4?style=flat&logoColor=white" alt="Eureka Client" /></td>
    <td></td>
  </tr>
</table>

## ⭐ API

<table>
    <thead>
        <tr style="font-weight: bold;">
            <th>메서드</th>
            <th>엔드포인트</th>
            <th>설명</th>
            <th>요청 데이터 및 쿼리 파라미터 예시</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>POST</td>
            <td>/api/auth/login</td>
            <td>로그인</td>
            <td>
                <details>
                    <summary>application/x-www-form-urlencoded</summary>
                    <pre>username=email0@example.com&password=Password1!</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>POST</td>
            <td>/api/auth/send-email-auth-code</td>
            <td>인증코드 발송</td>
            <td>
                <details>
                    <summary>application/json</summary>
                    <pre>{ "email": "exampz@naver.com" }</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>POST</td>
            <td>/api/auth/signup</td>
            <td>회원가입</td>
            <td>
                <details>
                    <summary>application/json</summary>
                    <pre>{
    "name": "홍길동",
    "email": "example@naver.com",
    "password": "Password1!",
    "confirmPassword": "Password1!",
    "tellNumber": "010-7777-7777",
    "address": "서울시 용산구 351 오오오",
    "authCode": "131327"
}</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>POST</td>
            <td>/api/orders</td>
            <td>주문 생성</td>
            <td>
                <details>
                    <summary>application/json</summary>
                    <pre>[{
    "wishlistItemId": 1505
},
{
    "wishlistItemId": 1504
}]</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>PATCH</td>
            <td>/api/orders/{orderId}/status</td>
            <td>주문 상태 변경</td>
            <td>
                <details>
                    <summary>application/json</summary>
                    <pre>"CANCEL"</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>GET</td>
            <td>/api/products/{productId}</td>
            <td>제품 조회</td>
            <td></td>
        </tr>
        <tr>
            <td rowspan="3">GET</td>
            <td rowspan="3">/api/products</td>
            <td>제품 목록 조회</td>
            <td>
                <details>
                    <summary>쿼리 파라미터</summary>
                    <pre>pageSize=5&listSort=PRICE_DESC&pageNumber=2&storeId=56</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>제품 검색</td>
            <td>
                <details>
                    <summary>쿼리 파라미터</summary>
                    <pre>pageSize=5&listSort=PRICE_DESC&pageNumber=2&searchKeyword=21</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>카테고리별 제품 조회</td>
            <td>
                <details>
                    <summary>쿼리 파라미터</summary>
                    <pre>pageSize=5&listSort=PRICE_DESC&pageNumber=2&productCategory=ACCESSORY</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>POST</td>
            <td>/api/wishlists</td>
            <td>위시리스트 생성</td>
            <td>
                <details>
                    <summary>application/json</summary>
                    <pre>[{
    "optionId": 1516,
    "quantity": 2
},
{
    "optionId": 1517,
    "quantity": 1
}]</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>GET</td>
            <td>/api/wishlists</td>
            <td>위시리스트 조회</td>
            <td>
                <details>
                    <summary>쿼리 파라미터</summary>
                    <pre>memberId=58</pre>
                </details>
            </td>
        </tr>
        <tr>
            <td>PATCH</td>
            <td>/api/wishlists/items/{itemId}/quantity</td>
            <td>위시리스트 항목 수량 변경</td>
            <td>
                <details>
                    <summary>application/json</summary>
                    <pre>{
  "action": "DECREASE"
}</pre>
                </details>
            </td>
        </tr>
    </tbody>
</table>

## ⭐ 요구사항

### 💊 회복 탄력성(Resilience) 적용

> 📌 Resilience4j
> 
> 외부 API 호출 시 발생할 수 있는 장애로부터 시스템을 보호하기 위해 **Resilience4j**를 도입하였습니다. 
> 
> Resilience4j는 외부 서비스의 장애가 우리의 API 서버에 미치는 영향을 최소화하는데 도움을 주며, 이를 통해 시스템의 회복 탄력성을 강화할 수 있었습니다.
>
> 
> <details>
> <summary>Resilience4j 도입 배경</summary>
> 
> Resilience4j를 사용하여 Circuit Breaker와 Retry 패턴을 적용함으로써 외부 API 호출의 안정성을 보장하고,
> 시스템 리소스를 보호하기 위한 회복 탄력성을 강화했습니다.
> 
> - Feign Client에 Circuit Breaker 및 Retry 적용
>   - Circuit Breaker: 서비스가 불안정할 때 자동으로 요청을 차단하여 시스템 과부하를 방지하고, 잠시 후 다시 시도할 수 있는 상태로 전환합니다.
>   - Retry: 서비스가 일시적으로 사용 불가능한 경우(예: 네트워크 문제, 서버 다운 등) 일정 횟수까지 재시도를 수행하여 일시적인 오류를 해결합니다.
> </details>

<details>
  <summary>Resilience4j 설정</summary>

#### 리플라이 설정
```yaml
resilience4j:
  retry:
    retry-aspect-order: 2 # 우선 순위 - 값이 높을수록 우선순위가 높아짐
    configs:
      default:
        max-attempts: 2 # 재시도 횟수
        wait-duration: 500 # 재시도 간격(총시간 = (재시도횟수 -1) * 재시도 간격 + 첫 시도 시간)
        retry-exceptions:
          - feign.FeignException.ServiceUnavailable  # 서버가 일시적으로 사용 불가능한 상태일 때 발생하는 예외
        ignore-exceptions:
          - feign.FeignException.BadGateway
          - feign.FeignException.NotImplemented
          - feign.FeignException.FeignClientException
    instances:
      simpleRetryConfig:
        baseConfig: default
```
- 최대 재시도 횟수(`max-attempts`)

  : 선착순 구매 시스템에서는 너무 많은 재시도가 오히려 시스템에 부담을 줄 수 있습니다. 따라서 재시도 횟수를 2-3회 정도로 낮게 설정하는 것이 적절합니다.

- 재시도 간격(`wait-duration`)

  : 짧은 wait-duration (예: 100-500ms)을 설정해 재시도를 빠르게 하지만, 너무 빈번한 시도는 피하는 것이 중요합니다. 재시도를 빠르게 하되 시스템에 무리를 주지 않도록 조정합니다.

- 처리할 예외

  - `feign.FeignException.ServiceUnavailable`
  : 서버가 일시적으로 사용 불가능할 때 발생하며, 재시도를 통해 해결 가능성이 있음.

- 무시할 예외

  - `feign.FeignException.BadGateway`
  : 재시도를 해도 즉각적으로 문제가 해결될 가능성이 낮아 게이트웨이 문제는 빠른 해결이 어렵거나 장기적인 문제일 수 있으므로, 재시도하지 않고 무시하는 것이 좋음

  - `feign.FeignException.NotImplemented`
  : 서버 측에서 해당 기능이 구현되어 있지 않거나 미지원인 상태이므로 재시도를 해도 성공할 가능성이 전혀 없기 때문에 재시도할 필요가 없음

  - `feign.FeignException.FeignClientException`
  : 잘못된 파라미터나 비정상적인 요청 형식 때문에 발생하기 때문에 재시도를 해도 클라이언트 측의 요청이 잘못된 경우에는 성공할 가능성이 없으므로, 이를 무시하고 재시도하지 않음

#### 서킷 브레이커 설정
```yaml
resilience4j:
  circuitbreaker:
    circuit-breaker-aspect-order: 1
    configs:
      default: # 설정 set (아래는 메서드들)
        sliding-window-type: COUNT_BASED
        minimum-number-of-calls: 7 # 최소 7번까지는 무조건 CLOSE로 가정하고 호출 (실제 메서드 호출은 리트라이 횟수를 곱해야함)
        sliding-window-size: 10 # (minimumNumberOfCalls 이후로는) 10개의 요청을 기준으로 판단
        wait-duration-in-open-state: 10s # OPEN 상태에서 HALF_OPEN으로 기다릴 시간

        failure-rate-threshold: 50 # slidingWindowSize 중 몇 %가 recordException이면 OPEN으로 만들 것인지

        slow-call-duration-threshold: 3000 # 몇 ms 동안 요청이 처리되지 않으면 실패로 간주
        slow-call-rate-threshold: 60 # slidingWindowSize 중 몇 %가 slowCall이면 OPEN으로 만들 것인가?

        permitted-number-of-calls-in-half-open-state: 5 # half open 상태에서 다른 상태로 전환하기 위한 판단 수(HALF_OPEN 상태에서 5번까지는 CLOSE로 가기위해 호출한다.)
        automatic-transition-from-open-to-half-open-enabled: true # OPEN 상태에서 자동으로 HALF_OPEN으로 갈 것인가?

        record-exceptions:
          - feign.FeignException.ServiceUnavailable # 서버가 일시적으로 사용 불가능한 상태일 때 발생하는 예외
          - feign.FeignException.GatewayTimeout # 서버가 게이트웨이로부터 응답을 기다리는 동안 시간이 초과된 경우 발생하는 예외
          - java.net.SocketTimeoutException
          - feign.FeignException.BadGateway # 다른 서버(게이트웨이)를 통해 잘못된 응답을 받았을 때 발생
        ignore-exceptions:
          - feign.FeignException.NotImplemented # 클라이언트의 요청을 처리할 방법을 지원하지 않는 경우 발생하는 예외
          - feign.FeignException.FeignClientException
    instances:
      simpleCircuitBreakerConfig:
        baseConfig: default
```
- 슬라이딩 윈도우 유형(`sliding-window-type`)

  : `COUNT_BASED` 선택. 선착순 시스템은 많은 요청이 들어오기 때문에 호출 수 기반으로 빠르게 상태를 결정할 수 있습니다.

- 슬라이딩 윈도우 크기(`sliding-window-size`)

  : 작은 sliding-window-size로 설정하여 적은 호출 수로도 상태를 빠르게 판단할 수 있습니다.

- 최소 호출 수(`minimum-number-of-calls`)

  : 5-10 정도로 설정하여 실패율에 빠르게 반응할 수 있도록 합니다. 이를 통해 급격한 트래픽 증가 시 빠르게 대응할 수 있습니다.

  - 설정하지 않으면 서버가 처음 시작된 직후 1~2번의 실패만으로도 서킷 브레이커가 너무 빠르게 열리는 상황이 발생할 수 있습니다.

- 실패율 임계값(`failure-rate-threshold`)

  : 비교적 낮은 임계값(40-50%)을 설정하여 일정 비율 이상의 호출이 실패할 경우 서킷 브레이커가 빠르게 열리도록 설정합니다. 
  
  - 선착순 구매 시스템에서는 문제가 발생했을 때 즉각적으로 대응해야 하기 때문에 낮은 임계값이 적합합니다.

- 반 개방 상태에서 허용할 호출 수 (`permitted-number-of-calls-in-half-open-state`)

  : 5-10회 정도로 설정하여 OPEN 상태에서 HALF_OPEN 상태로 전환될 때 천천히 트래픽을 재도입하고, 문제가 해결되었는지 확인할 수 있도록 합니다.

- 처리할 예외()

  - `feign.FeignException.ServiceUnavailable`
  : 서버의 서비스가 일시적으로 중단된 경우, 해당 예외는 시스템이 해당 서버에 대한 호출을 중단하고 다른 대체 동작을 시도하도록 유도하여 서킷브레이커로 감지하여 대기 시간을 줄이고 시스템의 리소스를 보호

  - `feign.FeignException.GatewayTimeout`
  : 서킷브레이커를 통해 더 이상의 시도를 막고, 일시적인 문제일 가능성이 있으므로 재시도 또는 대체 경로를 사용할 수 있도록 함

  - `java.net.SocketTimeoutException`
  : 소켓 연결 시 타임아웃은 일반적으로 네트워크 불안정성이나 서버 부하로 인해 발생하는 상황에서 서킷브레이커는 재시도나 대체 처리를 통해 시스템의 안정성을 유지

  - `feign.FeignException.BadGateway`
  : 502 Bad Gateway 오류가 자주 발생하거나, 오래 지속되는 경우에는 단순 재시도로는 해결되지 않는 문제가 있을 수 있기 때문에, 서킷브레이커를 작동시켜 해당 서비스로의 요청을 일시적으로 차단하는 것이 유리

- 무시할 예외

  - `feign.FeignException.NotImplemented`
  : 서버에서 기능을 지원하지 않음을 명확하게 알린 경우이므로, 이 예외는 재시도해도 의미가 없고 다른 방법으로 요청을 처리해야 할 상황이므로 서킷브레이커를 적용할 필요가 없음

  - `feign.FeignException.FeignClientException`
  : 클라이언트 측의 오류로 인해 발생하는 예외이기 때문에 재시도해도 성공할 가능성이 없음. 클라이언트에서 요청을 수정해야 하는 문제이므로 서킷브레이커를 적용할 필요가 없음
</details>

### ☁️ MSA 환경 구축

> #### 📌 Monolithic Architecture vs MicroService Architecture
>
> - MA(Monolithic Architecture)
> : 모든 기능이 하나의 애플리케이션 내부에 통합되어 있으며, 단일 코드베이스에서 작동하도록 하는 소프트웨어 설계
>   - 장점: 개발과 관리가 용이합니다.
>   - 단점: 시스템이 복잡해지고 커질수록 코드를 이해하기가 어려워지고 그럴수록 유지보수하기 어려워집니다.
> - MSA(Microservice Architecture)
> : 소프트웨어 시스템을 여러 작은 독립적인 서비스로 나누고, 각 서비스를 독립적으로 배포하고 운영하는 소프트웨어 설계
>   - 장점: 대규모 애플리케이션을 더 작고 관리 가능한 단위로 분해함으로써, 개발, 배포, 확장, 유지보수 등의 측면에서 더 높은 유연성과 확장성을 제공합니다.
>   - 단점: 여러 모듈들이 분산되어 있어 관리 및 모니터링이 힘들며, 통합 테스트가 힘듭니다.
> <details>
>  <summary>MA vs MSA 비교표</summary>  
>
> |           | MA (Monolithic Architecture) | MSA (Microservices Architecture) |
> |-----------|------------------------------|----------------------------------|
> | **구조**    | 하나의 통합된 애플리케이션               | 독립적인 여러 마이크로서비스                  |
> | **배포**    | 전체 시스템을 하나의 단위로 배포           | 각 서비스 개별 배포 가능                   |
> | **확장성**   | 전체 시스템 단위로 확장해야 함            | 필요한 서비스만 확장 가능                   |
> | **개발 속도** | 초기 개발은 빠름                    | 복잡도 높아 초기 구축이 어려울 수 있음           |
> | **유지 보수** | 코드베이스 커지면 어려워짐               | 서비스가 작아 유지 보수에 유리                |
> | **기술 스택** | 하나의 통일된 기술 스택 사용             | 각 서비스별로 다른 기술 스택 선택 가능           |
> | **복잡도**   | 상대적 단순                       | 서비스 간 통신, 데이터 일관성 관리가 어려움        |
> | **운영 비용** | 단순, 적은 운영 리소스 필요             |  많은 리소스 필요 (모니터링, 네트워크 통신 등)     |
> </details>
>
> <details>
> <summary>MSA 도입 배경</summary>
>
> - 확장성
>   : MSA는 개별 마이크로서비스 단위로 확장이 가능하여 특정 서비스의 트래픽이 많을 때만 확장이 가능합니다.
> - 유지보수
>   - 모든 기능이 통합된 하나의 코드베이스는 시간이 지남에 따라 복잡해집니다. 
>   - 코드 수정 시 다른 기능에 영향을 미치는 경우가 많아 유지보수가 어려워집니다. 
>   - MSA는 서비스 단위로 코드가 나뉘어져 있어 유지보수가 용이합니다.
> - 의존성
>   : MSA에서는 서비스 간 의존성을 줄일 수 있습니다.
> </details>

> #### 📌 Spring Cloud
> 
> 분산 시스템을 구축하기 위한 Spring Framework의 확장 도구
> 
> MSA 환경에서 마이크로서비스 간의 통신, 설정 관리, 서비스 디스커버리, 로드 밸런싱, 장애 복구, 모니터링 등 다양한 기능을 제공하여 마이크로서비스의 복잡한 인프라 문제를 쉽게 해결할 수 있도록 돕는 도구입니다.
> 
> <details>
>  <summary>Spring Cloud 도입 배경</summary>
>
> - 서비스 간 통신 문제 해결
>   - MSA 환경에서는 서비스들이 서로 다른 네트워크 상에서 통신해야 합니다. 
>   - 이를 쉽게 구현하기 위해 Spring Cloud는 서비스 디스커버리와 API Gateway를 제공합니다.
> - 설정 관리의 복잡성 해결
>   : 마이크로서비스가 많아질수록 각 서비스의 설정을 일관성 있게 관리하는 것이 어려워지는데, Spring Cloud Config를 통해 중앙에서 설정을 통합 관리할 수 있습니다.
> - 추적 및 모니터링의 필요성: 분산 추적과 모니터링 도구를 제공하여 운영의 투명성을 높입니다.
> </details>

<details>
  <summary>3개의 마이크로 서비스로 만들기</summary>

- 서비스
  - [X] 유저 서비스: 회원 로직(회원가입, 이메일 확인 등) 기능을 담당하는 서비스를 구현합니다.
  - [X] 상품 서비스: 상품 로직(상품 조회 등) 기능을 담당하는 서비스를 구현합니다.
  - [X] 주문 서비스: 주문 로직(주문 생성, 수정, 반품) 기능을 담당하는 서비스를 구현합니다.
- [X] 각 서비스는 독립적으로 배포 가능해야 합니다.

</details>

[//]: # (Feign client를 활용한 마이크로 서비스 간의 상호 작용)
<details>
  <summary>Feign client를 활용한 마이크로 서비스 간의 상호 작용</summary>

> #### 📌 서버간 통신
> 
> 서비스 기능별로 구분해서 독립적인 애플리케이션을 개발하면 각 서비스 간 통신을 해야하는 경우가 발생합니다.
> 
> 한 서버가 다른 서버에 통신을 요청하는 것을 서버간 통신이라고 합니다. 서버와 클라이언트의 구조가 되며 대표 적인 통신방식이 HTTP/HTTPS입니다.

> #### 📌 Feign Client
> 
> Spring Cloud에서 제공하는 HTTP 클라이언트로, 마이크로서비스 간의 통신을 간편하게 하기 위해 사용됩니다. 
> 
> REST API를 호출할 때 HTTP 요청을 직접 작성하는 대신, 인터페이스를 정의하고 필요한 서비스 호출을 메서드처럼 사용할 수 있게 해줍니다.

- 유저 서비스
  - [X] 유저관련 내부 통신 api 제공
    - `GET`,`/internal/v0/members/{memberId}/exists`: memberId 존재 유무 확인 api
- 상품 서비스
  - [X] 상품관련 내부 통신 api 제공
    - `PUT`,`/internal/v0/products/options/stock`:상품 재고 업데이트 api
- 주문 서비스
  - [X] 유저 서비스, 상품 서비스 내부 통신 api feign client를 활용해 상호 작용
    ```java
    @FeignClient(name = "member")
    public interface UserFeignClient {
    
      @GetMapping("/internal/v0/members/{memberId}/exists")
      boolean existsMemberId(@PathVariable Long memberId);
    
    }
    ```
    ```java
    @FeignClient(name = "product")
    public interface ProductFeignClient {
    
      @PutMapping("/internal/v0/products/options/stock")
      void updateProductStock(@RequestBody UpdateQuantityByProductOptionsDto dto);
    
    }
    ```
</details>

[//]: # (Spring Cloud Gateway 만들기)
<details>
  <summary>Spring Cloud Gateway 만들기</summary>

> #### 📌 Spring Cloud Gateway
> 
> MSA 가장 앞단에서 클라이언트들로 부터 오는 요청을 받은 후 경로와 조건에 알맞은 마이크로서비스 로직에 요청을 전달하는 게이트웨이

> #### 📌 도입 배경
> 
> 클라이언트에 제공되는 API가 세 서비스로 분산되어 있어  
> 클라이언트는 각 서버가 제공하는 API 목록을 알아야 하며, 
> 각 서버에 맞는 요청을 보내야 합니다.
> 
> 각 서버의 정보를 클라이언트가 알아야해서 불편하고, 서비스 구조가 외부로 공개된다는 단점이 있어 Gateway가 필요합니다.

- [X] API GATEWAY 서비스를 새로 만들어 실행시키기(port: 8080)
- [X] 기존의 모노리스 서비스가 가지고 있던 모든 API 들을 API GATEWAY에 노출한다.
- [X] 해당 API로 들어온 요청을, 내부의 마이크로 서비스로 전달한다.

</details>

[//]: # (Eureka Server 만들기)
<details>
  <summary>Eureka Server 만들기</summary>

> #### 📌 Eureka Server
>
> Eureka는 Netflix에서 개발한 서비스 등록 및 디스커버리(발견) 도구로, MSA 환경에서 서비스 간 통신을 돕기 위해 각 서비스의 정보를 관리합니다. Eureka Server는 마이크로서비스들을 등록하고, 서로의 위치를 찾아주는 역할을 합니다.

> #### 📌 도입 배경
>
> MSA에서는 서비스들이 독립적으로 배포되며, 각 서비스의 위치(IP, 포트)가 동적으로 변할 수 있습니다. 이를 해결하기 위해 서비스의 위치 정보를 동적으로 관리하는 Eureka Server가 필요합니다. 클라이언트는 Eureka에 등록된 서비스 주소를 통해 해당 서비스에 접근할 수 있습니다.

- [X] Eureka Server를 Spring Boot로 구성 (port: 8761)
- [X] `@EnableEurekaServer` 애너테이션으로 Eureka Server 활성화
- [X] 각 마이크로서비스들이 Eureka Client로 등록되도록 설정
- [X] Eureka Dashboard로 각 서비스 상태 확인 (http://localhost:8761)

</details>

[//]: # (Config Server & Config Repository 만들기)
<details>
  <summary>Config Server & Config Repository 만들기</summary>

> #### 📌 Config Server
>
> Config Server는 외부 설정 파일을 중앙에서 관리하며, 모든 마이크로서비스가 설정을 공유하고 동기화할 수 있도록 돕는 도구입니다. 이를 통해 서비스 재시작 없이 설정을 동적으로 변경할 수 있습니다.

> #### 📌 도입 배경
>
> MSA 환경에서는 서비스마다 개별 설정이 존재하며, 이를 관리하는 것이 복잡합니다. Config Server를 사용하면 모든 설정을 중앙에서 관리하고 버전 관리가 가능해져, 서비스 간 설정 불일치 문제를 해결할 수 있습니다.

- [X] Spring Cloud Config Server를 사용하여 Config Server를 구축 (port: 8888)
- [X] Github를 Config Repository로 활용하여 설정 파일 관리
- [X] 각 마이크로서비스는 Config Server를 통해 설정을 로드하도록 설정
- [X] `@EnableConfigServer` 애너테이션을 사용하여 Config Server 활성화
- [X] Git Repository에 `*.yml` 파일을 생성하여 마이크로서비스별 설정 파일 저장

</details>

### ✅ 자동 테스트

본 프로젝트는 자동화된 테스트를 사용하여 안정성을 보장합니다.

> #### 커버리지 및 품질 결과
>
> - **JaCoCo 보고서**:
>   - 테스트 커버리지는 전체 코드베이스의 92.7%에 달하며, 이를 통해 주요 비즈니스 로직이 충분히 검증되었음을 확인했습니다.
> - **SonarQube 분석 결과**:
>   - SonarQube에서 보안, 신뢰성, 유지보수성 측면에서 모두 A 등급을 받았으며, 코드 품질에 대한 높은 기준을 유지하고 있습니다.
>   - 중복 코드 비율은 0.0%이며, 보안 취약점 및 핫스팟도 발견되지 않았습니다.


<details>
  <summary>테스트 종류 및 계층</summary>

  - **Controller 단위 테스트**:
    - Controller 계층에서는 JUnit5와 Mockito를 사용하여 단위 테스트를 수행했습니다. 이를 통해 각 Controller 메서드의 로직을 개별적으로 검증하고, Mock 객체를 사용하여 종속성을 분리하였습니다.

  - **Service 및 Repository 통합 테스트**:
    - Service 및 Repository 계층에서는 통합 테스트를 진행하여 각 계층 간의 상호작용을 검증했습니다. 이를 통해 실제 데이터베이스와의 연동을 포함한 통합적인 로직의 정상 작동을 보장하였습니다.

</details>

<details>
  <summary>사용 도구</summary>

  - **JUnit5**:
    - 프로젝트의 주요 테스트 프레임워크로 사용되었으며, 각 계층의 테스트 케이스를 작성하고 실행하는 데 사용되었습니다.

  - **Mockito**:
    - Controller 단위 테스트에서 의존성 주입을 Mocking하여 외부 종속성과의 결합을 줄이고, 독립적으로 메서드를 테스트하기 위해 사용되었습니다.

  - **JaCoCo**:
    - 코드 커버리지 분석 도구로, 테스트 케이스가 전체 코드베이스에서 얼마나 많은 부분을 커버하고 있는지 확인하기 위해 사용했습니다. 현재 프로젝트의 커버리지는 92.7%입니다.

  - **SonarQube**:
    - 코드 품질 분석 도구로, 코드 내의 잠재적인 버그, 보안 문제, 중복 코드, 유지보수성 등을 검토하고, 코드 품질을 지속적으로 개선하기 위해 사용했습니다.

</details>


### 🙆🏻‍♀️ 유저 서비스
<details>
  <summary>회원가입 및 로그인</summary>

  - 회원가입 기능을 통해 사용자는 계정을 생성할 수 있습니다.
      - [x] 이메일 인증을 통한 회원가입 기능을 만든다.
      - [x] 개인정보, `이름, 비밀번호, 주소, 이메일`은 `암호화`하여 저장한다.

  <figure>
      <img src="https://github.com/user-attachments/assets/24f380ed-2579-4b2a-8b6b-f3c675795769" alt="회원가입 및 로그인">
      <figcaption>회원가입 및 로그인</figcaption>
  </figure>

  - 로그인 시 access-token 발급한다.
</details>

### 📦 상품 서비스

<details>
  <summary>상품 상세&리스트 조회</summary>

- [x] 등록되어 있는 상품의 리스트를 보여주고 사용자가 구매할 수 있는 인터페이스를 제공합니다.
- [x] 상품을 클릭시 상품의 상세 정보를 제공해야합니다.
   - 상품의 재고 관리를 위한 유저 인터페이스는 별도로 구현하지 않습니다.

  <figure>
      <img src="https://github.com/user-attachments/assets/3c17a6a0-1a31-4d72-bc2b-4ca9c3e81a42" alt="상품 조회">
      <figcaption>상품 조회</figcaption>
  </figure>
</details>


### 💸 주문 서비스

<details>
  <summary>위시리스트 등록 및 조회</summary>

- [x] 사용자의 노출된 상품에 한하여 주문 및 WishList에 등록
- [x] WishList에서 내가 등록한 상품에 대한 정보 조회
  - [x]  제품의 상세 페이지로 이동
- [x]  상품의 수량 변경
- [x]  위시리스트 내 항목의 수정

  <figure>
      <img src="https://github.com/user-attachments/assets/c6032fdd-3967-4e4b-b82b-fc4ff029a4fc" alt="위시리스트 로직">
      <figcaption>위시리스트 로직</figcaption>
  </figure>
</details>

<details>
  <summary>마이페이지에서 주문 생성</summary>

- [x] 마이페이지에서 위시리스트를 통해 주문을 생성할 수 있습니다.

  <figure>
      <img src="https://github.com/user-attachments/assets/5ee65301-ace7-4fc7-a3cc-db5d1fe5078f" alt="상품 조회">
      <figcaption>마이페이지에서 주문 생성</figcaption>
  </figure>
</details>

<details>
  <summary>주문 상태 자동 변경</summary>

- [x] 주문 상태 변경
  -  주문 상품에 대한 상태 조회(주문 후 D+1에 배송 중, D+2일에 배송 완료가 됩니다.)

  <figure>
      <img src="https://github.com/user-attachments/assets/2b52b6ae-859f-4dff-a113-8e0afff3aa74" alt="주문 상태 자동 변경">
      <figcaption>주문 상태 자동 변경</figcaption>
  </figure>
</details>

<details>
  <summary>주문 취소</summary>

- 상품에 대한 주문 취소 기능을 제공합니다.
  - 주문 내역중 일부 상품에 대한 취소는 없다고 가정합니다.
- [x] `주문 취소`
  - 주문 상태가 배송중이 되기 이전까지만 취소가 가능합니다.
  - 취소 후에 는 상품의 재고를 복구 되어야 합니다 주문 취소 후 상태는 취소 완료로 변경 됩니다.

  <figure>
      <img src="https://github.com/user-attachments/assets/c72fe038-b81f-4cfa-9d2d-9e26944b8c9f" alt="주문 취소">
      <figcaption>주문 취소</figcaption>
  </figure>
</details>

<details>
  <summary>주문 반품</summary>

- 상품에 대한 주문 반품 기능을 제공합니다.
  - 주문 내역중 일부 상품에 대한 반품은 없다고 가정합니다.
- [x] `반품신청`
  - 배송 완료 후 D+1일까지만 반품이 가능하고 그 이후에는 반품이 불가능 합니다.
  - 배송 완료가 된 상품에 대해서만 반품이 가능합니다.
- [x] `반품완료`
  - 반품한 상품은 반품 신청 후 D+1에 재고에 반영 됩니다. 재고에 반영된 후 상태는 반품 완료로 변경됩니다.

  <figure>
      <img src="https://github.com/user-attachments/assets/9187d156-26ef-4aff-94e5-a7d711c340f7" alt="주문 반품">
      <figcaption>주문 반품</figcaption>
  </figure>

</details>

## ⭐ 데이터베이스
![DB](https://github.com/user-attachments/assets/d5e4915b-ebf8-4d07-8e0f-c89a20fa5cbc)

